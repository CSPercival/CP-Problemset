// Template generated by Clank
#include<bits/stdc++.h>
using namespace std;
#define st first
#define nd second
#define all(x) x.begin(), x.end()
#define BOOST cin.tie(NULL); ios_base::sync_with_stdio(false);
// #define int ll
typedef long long ll;

struct SuffixArray{
    int n;
    vector<int> text;
    vector<int> p;
    vector<int> c;
    vector<int> cnt;
    vector<int> lcp;
    
    SuffixArray(string intext){
        intext.push_back('#');
        // intext.push_back('~');
        text = vector<int>(all(intext));
        n = text.size();
        p.resize(n);
        c.resize(n);
        lcp.resize(n);
        compute();
    }

    void compute(){
        CountingSort(text, p, 256,
                    [](int val){return val;},
                    [](int idx){return idx;});
                
        int eqc = 0;
        c[p[0]] = 0;
        for(int i = 1; i < n; i++){
            if(text[p[i]] != text[p[i - 1]]) eqc++;
            c[p[i]] = eqc;
        }
        int step = 1;
        vector<pair<pair<int,int>, int>> tmp(n);
        vector<pair<pair<int,int>, int>> tmp2(n);
        while(step < n) {
            for(int i = 0; i < n; i++){
                tmp[i] = {{c[i], c[(i + step) % n]}, i};
            }
            CountingSort(tmp, tmp2, eqc,
            [](pair<pair<int,int>, int> val){return val.st.nd;},
            [&tmp](int idx){return tmp[idx];});
            
            CountingSort(tmp2, tmp, eqc,
            [](pair<pair<int,int>, int> val){return val.st.st;},
            [&tmp2](int idx){return tmp2[idx];});

            eqc = 0;
            c[tmp[0].nd] = 0;
            for(int i = 1; i < n; i++){
                if(tmp[i].st != tmp[i - 1].st) eqc++;
                c[tmp[i].nd] = eqc;
            }
            step <<= 1;
        }

        for(int i = 0; i < n; i++){
            p[c[i]] = i;
        }

        int k =0;
        for(int i = 0; i < n - 1; i ++){
            while(text[i + k] == text[p[c[i] - 1] + k]) k++;
            lcp[c[i]] = k;
            k = max(k - 1, 0);
        }
    }
    
    template <class T, class G, typename F1, typename F2>
    void CountingSort(vector<G> &oa, vector<T> &na, int lim, F1 get, F2 new_val){
        cnt.assign(lim + 2, 0);
        for(auto x : oa){
            cnt[get(x) + 1]++;
        }
        for(int i = 1; i <= lim; i++) cnt[i] += cnt[i - 1];
        for(int i = 0; i < oa.size(); i++){
            na[cnt[get(oa[i])]++] = new_val(i);
        }
    }
};

int max_lcp(int idx, SuffixArray *sa){
    int tidx = sa->c[idx];
    return max(sa->lcp[tidx], sa->lcp[tidx + 1]);
}

int32_t main(){
    BOOST;
    string text; cin >> text;
    text = "~" + text;
    
    SuffixArray sa(text);
    
    // exit(0);

    int ans = 1;
    for(int i = 1; i < text.size() - 1; i++){
        int mlcp = max_lcp(i, &sa);
        if(mlcp + i >= text.size()) continue;
        if(max_lcp(i + 1, &sa) >= mlcp){
            ans = max(ans, mlcp + 1);
        }
    }
    cout << ans << "\n";
    return 0;
}
