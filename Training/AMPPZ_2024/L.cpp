// Template generated by Clank
#include<bits/stdc++.h>
using namespace std;
#define st first
#define nd second
#define all(x) x.begin(), x.end()
#define BOOST cin.tie(NULL); ios_base::sync_with_stdio(false);
// #define int ll
typedef long long ll;

ll lim = 1e11;
pair<ll, int> pzero = {1e15, 1e9};

struct Hash{
    ll n;
    ll p;
    ll mod;
    string s;
    vector<ll> h;
    vector<ll> pk;
    vector<ll> h2;
    vector<ll> pk2;
    vector<ll> siz2;

    void compute(int inp, int inmod){
        p = inp;
        mod = inmod;
        n = s.size();
        h.resize(n);
        pk.resize(n);
        pk[0] = 1;
        h[0] = 0;
        for(int i = 1; i < n; i++){
            h[i] = (h[i - 1] * p + s[i] - 'A' + 1) % mod;
            pk[i] = (pk[i - 1] * p) % mod;
        }
        h2.push_back(h[n - 1]);
        pk2.push_back(pk[n - 1]);
        siz2.push_back(n - 1);
        while(siz2.back() < lim){
            h2.push_back((h2.back() * pk2.back() + h2.back()) % mod);
            pk2.push_back((pk2.back() * pk2.back()) % mod);
            siz2.push_back(siz2.back() << 1);
        }
    }

    int letter(ll idx){
        return s[(idx % (n - 1)) + 1];
    }

    ll get_hash(ll idx){
        if(idx < n - 1) return h[idx + 1];
        
        ll tsiz = 0;
        ll thash = 0;
        idx++;
        for(int i = (int)siz2.size() - 1; i >= 0; i--){
            if(tsiz + siz2[i] <= idx){
                thash = (thash * pk2[i] + h2[i]) % mod;
                tsiz += siz2[i];
            }
        }
        assert(tsiz <= idx);
        assert(idx - tsiz <= n - 1);
        return (thash * pk[idx - tsiz] + h[idx - tsiz]) % mod;
    }
};

vector<Hash> plr;

ll diff(Hash *h1, Hash *h2){
    ll p = -1, k = (h1->n * h2->n) + 1, sr;
    while(p + 1 < k){
        sr = (p + k) / 2;
        if(h1->get_hash(sr) == h2->get_hash(sr)){
            p = sr;
        } else {
            k = sr;
        }
    }
    return k;
}

bool cmp(int i1, int i2){
    ll d = diff(&(plr[i1]), &(plr[i2]));
    return plr[i1].letter(d) < plr[i2].letter(d);
}

struct SegTree{
    int n;
    int shift = 1;
    vector<pair<ll,int>> t;
    SegTree(int inn, vector<ll> &a) : n(inn){
        while(shift <= n) shift <<= 1;
        t.assign(2 * shift, pzero);
        for(int i = 0; i < n; i++){
            t[shift + i] = {a[i], i};
        }
        for(int i = shift - 1; i > 1; i--){
            t[i] = min(t[i * 2], t[i * 2 + 1]);
        }
    }

    pair<ll,int> query(int l, int r){
        pair<ll,int> ans = pzero;
        for(l += shift, r += shift; l < r; l >>= 1, r >>= 1){
            if(l&1) ans = min(ans, t[l++]); 
            if(r&1) ans = min(ans, t[--r]); 
        }
        return ans;
    }
};

ll answer = 0;
string tabs = "";

void rek(int l, int r, SegTree *t){
    if(r - l < 2){
        return;    
    }
    pair<ll, int> tmpp = t->query(l, r);
    pair<ll, int> tmpp2 = t->query(tmpp.nd + 1, r);
    tabs.push_back(' ');
    if(tmpp == pzero || tmpp.st == lim){
        return;    
    }
    if(tmpp.st == tmpp2.st){
        answer += (ll)(tmpp.nd - l + 1) * (tmpp2.nd - tmpp.nd) * (r - tmpp2.nd);
        rek(l, tmpp.nd, t);
        rek(tmpp.nd + 1, tmpp2.nd, t);
        rek(tmpp2.nd + 1, r, t);
    } else {
        rek(l, tmpp.nd, t);
        rek(tmpp.nd + 1, r, t);
    }
    tabs.pop_back();
}

int32_t main(){
    BOOST;
    int n; cin >> n;
    string tmps;
    plr.resize(n);
    vector<int> splr(n);
    for(int i = 0; i < n; i++){
        cin >> tmps;
        plr[i].s = "$" + tmps;
        plr[i].compute(37, 888173173);
        splr[i] = i;
    }

    sort(all(splr), cmp);

    vector<ll> dl(n - 1);
    for(int i = 0; i < n - 1; i++){
        dl[i] = diff(&(plr[splr[i]]), &(plr[splr[i + 1]]));
        if(plr[splr[i]].letter(dl[i]) == plr[splr[i + 1]].letter(dl[i])) dl[i] = lim;
    }

    SegTree t(n - 1, dl);

    rek(0, n - 1, &t);
    cout << answer << "\n";
    return 0;
}