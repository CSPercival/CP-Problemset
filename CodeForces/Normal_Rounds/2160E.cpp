// This file was generated by Clank
#include<bits/stdc++.h>
#define st first
#define nd second
#define all(x) x.begin(), x.end()
#define BOOST cin.tie(NULL); ios_base::sync_with_stdio(false);
 
// #define int ll
typedef long long ll;

using namespace std;
template <typename T> struct tag:reference_wrapper <T>{ using reference_wrapper <T>::reference_wrapper; };
template <typename T1, typename T2> static inline tag <ostream> operator<<(tag <ostream> os, pair<T1, T2> const& p){ return os.get()<<"{"<<p.first<<", "<<p.second<<"}", os;}
template <typename Other> static inline tag <ostream> operator<<(tag <ostream> os, Other const& o){ os.get()<<o; return os; }
template <typename T> static inline tag <ostream> operator <<(tag <ostream> os, vector <T> const& v){ os.get()<<"["; for (int i=0; i<v.size(); i++) if (i!=v.size()-1) os.get()<<v[i]<<", "; else os.get()<<v[i]; return os.get()<<"]", os; }
template <typename T> static inline tag <ostream> operator <<(tag <ostream> os, set <T> const& s){ vector <T> v; for (auto i: s) v.push_back(i); os.get()<<"["; for (int i=0; i<v.size(); i++) if (i!=v.size()-1) os.get()<<v[i]<<", "; else os.get()<<v[i]; return os.get()<<"]", os; }

template <typename T>
vector<vector<T>> Transposition(vector<vector<T>> &grid){
    int n = grid.size();
    int m = grid[0].size();
    vector<vector<T>> ans(m, vector<T>(n));
    for(int i = 0; i < n; i++){
        for(int j = 0; j < m; j++){
            ans[j][n - 1 - i] = grid[i][j];
        }
    }
    return ans;
}

int rectangle_size(int r1, int r2, int c1, int c2){
    return (abs(r1 - r2) + 1) * (abs(c1 - c2) + 1);
}

void preprocess_minis(int n, vector<vector<int>> &minis,vector<vector<int>> &segs){
    for(int i = 0; i < n; i++){
        minis[i][0] = segs[i][n - 1];
        for(int j = 1; j < n; j++){
            minis[i][j] = min(minis[i][j - 1], segs[i][n - 1 - j]);
        }
    }
}

// int last_seen[510][510];
// vector<int> 

void solve(){
    int n, m ; cin >> n >> m;
    char cc;
    vector<vector<int>> grid(n, vector<int>(m));
    for(int i = 0; i < n; i++){
        for(int j = 0; j < m; j++){
            cin >> cc;
            grid[i][j] = cc - '0';
        }
    }
    int did_swap = 0;
    if(n > m){
        did_swap = 1;
        swap(n, m);
        grid = Transposition<int>(grid);
    }
    vector<vector<int>> ans(n, vector<int>(m, -1));

    vector<vector<int>> last_seen(n, vector<int>(n, -1));
    vector<vector<pair<pair<uint16_t,uint16_t>,int>>> events_add(m + 1);
    vector<vector<pair<pair<uint16_t,uint16_t>,int>>> events_del(m + 1);
    // multiset<pair<int,int>> events;
    vector<vector<int>> segs(n + 1, vector<int>(n + 1, 1e9));
    // multiset<int> minis;
    vector<vector<int>> minis(n + 1, vector<int>(n + 1, 1e9));

    for(int col = 0; col < m; col++){
        // cout << "col: " << col << " ------------------\n";
        for(int row1 = 0; row1 < n; row1++){
            if(!grid[row1][col]) continue;
            for(int row2 = row1 + 1; row2 < n; row2++){
                if(!grid[row2][col]) continue;
                if(last_seen[row1][row2] != -1){
                    events_add[last_seen[row1][row2]].push_back({{row1, row2}, rectangle_size(row1, row2, last_seen[row1][row2], col)});
                    events_del[col].push_back({{row1, row2}, (int)1e9});
                }
                last_seen[row1][row2] = col;
            }
        }
    }

    for(int col = 0; col < m; col++){
        for(auto evupd : events_add[col]){
            segs[evupd.st.st][evupd.st.nd] = min(segs[evupd.st.st][evupd.st.nd], evupd.nd);
        }
        preprocess_minis(n, minis, segs);
        
        for(int row = 0; row < n; row++){
            ans[row][col] = 1e9;
            for(int step = 0; step <= row; step++){
                ans[row][col] = min(ans[row][col], minis[step][n - 1 - row]);
            }
        }
        for(auto evupd : events_del[col]){
            segs[evupd.st.st][evupd.st.nd] = evupd.nd;
        }
        for(auto evupd : events_add[col]){
            segs[evupd.st.st][evupd.st.nd] = evupd.nd;
        }
    }

    if(did_swap){
        swap(n, m);
        ans = Transposition<int>(ans);
        ans = Transposition<int>(ans);
        ans = Transposition<int>(ans);
    }

    for(int i = 0; i < n; i++){
        for(int j = 0; j < m; j++){
            if(ans[i][j] == 1e9) ans[i][j] = 0;
            cout << ans[i][j] << " ";
        }
        cout << "\n";
    }
    // cout << grid << "\n";
}

 
int32_t main(){
    // BOOST;
 
    int q = 1; cin >> q;
    while(q--){
        solve();
    }
    return 0;
}
