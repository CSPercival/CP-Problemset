// This file was generated by Clank
#include<bits/stdc++.h>
#define st first
#define nd second
#define all(x) x.begin(), x.end()
#define BOOST cin.tie(NULL); ios_base::sync_with_stdio(false);
 
// #define int ll
typedef long long ll;

using namespace std;
template <typename T> struct tag:reference_wrapper <T>{ using reference_wrapper <T>::reference_wrapper; };
template <typename T1, typename T2> static inline tag <ostream> operator<<(tag <ostream> os, pair<T1, T2> const& p){ return os.get()<<"{"<<p.first<<", "<<p.second<<"}", os;}
template <typename Other> static inline tag <ostream> operator<<(tag <ostream> os, Other const& o){ os.get()<<o; return os; }
template <typename T> static inline tag <ostream> operator <<(tag <ostream> os, vector <T> const& v){ os.get()<<"["; for (int i=0; i<v.size(); i++) if (i!=v.size()-1) os.get()<<v[i]<<", "; else os.get()<<v[i]; return os.get()<<"]", os; }
template <typename T> static inline tag <ostream> operator <<(tag <ostream> os, set <T> const& s){ vector <T> v; for (auto i: s) v.push_back(i); os.get()<<"["; for (int i=0; i<v.size(); i++) if (i!=v.size()-1) os.get()<<v[i]<<", "; else os.get()<<v[i]; return os.get()<<"]", os; }

struct Path{
    int s1,r,s2,len;
};

class ComparePath{
public:
    bool operator() (Path a, Path b){
        if(a.len != b.len) return a.len < b.len;
        if(a.s1 != b.s1) return a.s1 < b.s1;
        return a.s2 < b.s2;
    }
};

void printpath(Path p){
    cout << p.s1 << " " << p.r << " " << p.s2 << " " << p.len << endl;
}
void printpair(pair<int,int> p){
    cout << p.st << " " << p.nd << endl;
}

void printpq(priority_queue<Path, vector<Path>, ComparePath> pq){
    while(!pq.empty()){
        printpath(pq.top());
        pq.pop();
    }
}

struct Tree{
    vector<set<int>> g;
    vector<int> par;
    vector<int> roots;
    vector<int> ans_seq;
    // vector<int> dep;
    int n;
    Tree(int inn){
        n = inn;
        int u,v;
        g.resize(n + 1);
        par.resize(n + 1);
        // dep.resize(n + 1);
        for(int i = 0; i < n - 1; i++){
            cin >> u >> v;
            g[u].insert(v);
            g[v].insert(u);
        }
    }
    
    void comp(pair<int,int> *p1, pair<int,int> *p2){
        if(p1->st < p2->st || (p1->st == p2->st && p1->nd < p2->nd)){
            // swap((*p1), (*p2));
            pair<int,int> tmp = (*p2);
            (*p2) = (*p1);
            (*p1) = tmp; 
        }
    }

    pair<int,int> dfs(int idx, Path &ans){
        // cout << "DFS " << idx << endl; 
        pair<int,int> best = {0,idx}, best2 = {0,idx}, tmp;
        for(int i : g[idx]){
            if(i == par[idx]) continue;
            par[i] = idx;
            // dep[i] = dep[idx] + 1;
            // cout << "GO DFS " << i << endl;
            tmp = dfs(i, ans);
            // cout << "BACK DFS " << idx << endl;

            // dep[idx] = max(dep[idx], tmp.st + 1);
            // printpair(tmp);
            // printpair(best);
            // printpair(best2);
            comp(&best,&tmp);
            comp(&best2,&tmp);
            // printpair(tmp);
            // printpair(best);
            // printpair(best2);
        }
        int tmps1 = max(best.nd,best2.nd);
        int tmps2 = min(best.nd,best2.nd);
        if(ans.len < best.st + best2.st + 1){
            ans = {tmps1, idx, tmps2, best.st + best2.st + 1};
        } else {
            if(ans.len == best.st + best2.st + 1){
                if(ans.s1 < tmps1 || (ans.s1 == tmps1 && ans.s2 < tmps2)){
                    ans = {tmps1, idx, tmps2, best.st + best2.st + 1};
                }
            }
        }
        best.st += 1;
        return best;
    }

    Path find_best(int root){
        Path ans = {0, 0, 0, -1};
        par[root] = 0;
        dfs(root, ans);
        return ans;
    }

    void remver(int idx){
        for(int i : g[idx]){
            g[i].erase(idx);
            if(par[i] == idx){
                par[i] = 0;
                roots.push_back(i);
            }
        }
    }

    void go(Path bp){
        ans_seq.push_back(bp.len);
        ans_seq.push_back(bp.s1);
        ans_seq.push_back(bp.s2);
        // cout << bp.s1 << " " << bp.r << " " << bp.s2 << " " << bp.len << endl;
        while(bp.s1 != bp.r){
            remver(bp.s1);
            g[bp.s1].clear();
            bp.s1 = par[bp.s1];
        }
        while(bp.s2 != bp.r){
            remver(bp.s2);
            g[bp.s2].clear();
            bp.s2 = par[bp.s2];
        }
        remver(bp.r);
        if(par[bp.r] != 0){
            roots.push_back(par[bp.r]);
        }
    }

};

void solve(){
    int n; 
    cin >> n;
    
    Tree t(n);
    priority_queue<Path, vector<Path>, ComparePath> pq;
    // cout << "ok1" << endl;
    // set<int> roots;
    // roots.insert(1);
    // vector<int> nroots;
    t.roots.push_back(1);
    Path bpath;
    while(true){
        // cout << "MAIN WHILE" << endl;
        // cout << t.roots << "\n";
        while(!t.roots.empty()){
            int root = t.roots.back();
            t.roots.pop_back();
            pq.push(t.find_best(root));
        }
        // cout << "PQ\n";
        // printpq(pq);
        // cout << "END PQ\n";
        // cout << "ROOTS DONE" << endl;
        // cout << pq << "\n";
        if(pq.empty()) break;
        t.go(pq.top());
        pq.pop();
        // cout << t.ans_seq << "\n";
        // cout << "PATH ADDED" << endl;
    }
    for(int i = 0; i < t.ans_seq.size(); i++){
        cout << t.ans_seq[i] << " ";
    }
    cout << "\n";
}

 
int32_t main(){
    BOOST;
 
    int q = 1; cin >> q;
    while(q--){
        solve();
    }
    return 0;
}
