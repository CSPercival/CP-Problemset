// This file was generated by Clank
#include<bits/stdc++.h>
#define st first
#define nd second
#define all(x) x.begin(), x.end()
#define BOOST cin.tie(NULL); ios_base::sync_with_stdio(false);
 
// #define int ll
typedef long long ll;
 
using namespace std;
template <typename T> struct tag:reference_wrapper <T>{ using reference_wrapper <T>::reference_wrapper; };
template <typename T1, typename T2> static inline tag <ostream> operator<<(tag <ostream> os, pair<T1, T2> const& p){ return os.get()<<"{"<<p.first<<", "<<p.second<<"}", os;}
template <typename Other> static inline tag <ostream> operator<<(tag <ostream> os, Other const& o){ os.get()<<o; return os; }
template <typename T> static inline tag <ostream> operator <<(tag <ostream> os, vector <T> const& v){ os.get()<<"["; for (int i=0; i<v.size(); i++) if (i!=v.size()-1) os.get()<<v[i]<<", "; else os.get()<<v[i]; return os.get()<<"]", os; }
template <typename T> static inline tag <ostream> operator <<(tag <ostream> os, set <T> const& s){ vector <T> v; for (auto i: s) v.push_back(i); os.get()<<"["; for (int i=0; i<v.size(); i++) if (i!=v.size()-1) os.get()<<v[i]<<", "; else os.get()<<v[i]; return os.get()<<"]", os; }
 
const int mod = 1e9 + 7;
int pi[1005010];
void compute_pattern(string text, vector<vector<int>> &moves, int pat_len){
    int n = text.size();
    int pidx = 0;
    pi[0] = 0;
    for(int i = 1; i < n; i++){
        pidx = pi[i - 1];
        while(pidx > 0 && text[i] != text[pidx]) pidx = pi[pidx - 1];
        if(text[i] == text[pidx]) pidx++;
        pi[i] = pidx;
        if(pi[i] == pat_len){
            moves[i - pat_len].push_back(pat_len);
        }
    }
}
 
void solve(){
    string text;
    cin >> text;
    int n = text.size();
    int k; cin >> k;
    string pat;
    vector<vector<int>> moves(n + 2);
    vector<int> dp(n + 2);
    text = "#" + text;
    for(int i = 0; i < k; i++){
        cin >> pat;
        compute_pattern(pat + text, moves, pat.size());
    }
    dp[0] = 1;
    for(int i = 1; i <= n; i++){
        for(auto move : moves[i]){
            // dp[i] = (dp[i] + dp[i - move]) % mod; 
            dp[i] += dp[i - move];
            if(dp[i] > mod) dp[i] -= mod;
        }
    }
    cout << dp[n] << "\n";
}
 
 
int32_t main(){
    BOOST;
 
    solve();
    return 0;
}